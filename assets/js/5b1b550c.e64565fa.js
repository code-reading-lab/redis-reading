"use strict";(self.webpackChunkredis_reading=self.webpackChunkredis_reading||[]).push([[5932],{3905:(e,n,r)=>{r.d(n,{Zo:()=>c,kt:()=>E});var t=r(7294);function i(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function a(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,t)}return r}function o(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?a(Object(r),!0).forEach((function(n){i(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function d(e,n){if(null==e)return{};var r,t,i=function(e,n){if(null==e)return{};var r,t,i={},a=Object.keys(e);for(t=0;t<a.length;t++)r=a[t],n.indexOf(r)>=0||(i[r]=e[r]);return i}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(t=0;t<a.length;t++)r=a[t],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var s=t.createContext({}),l=function(e){var n=t.useContext(s),r=n;return e&&(r="function"==typeof e?e(n):o(o({},n),e)),r},c=function(e){var n=l(e.components);return t.createElement(s.Provider,{value:n},e.children)},f="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},u=t.forwardRef((function(e,n){var r=e.components,i=e.mdxType,a=e.originalType,s=e.parentName,c=d(e,["components","mdxType","originalType","parentName"]),f=l(r),u=i,E=f["".concat(s,".").concat(u)]||f[u]||p[u]||a;return r?t.createElement(E,o(o({ref:n},c),{},{components:r})):t.createElement(E,o({ref:n},c))}));function E(e,n){var r=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var a=r.length,o=new Array(a);o[0]=u;var d={};for(var s in n)hasOwnProperty.call(n,s)&&(d[s]=n[s]);d.originalType=e,d[f]="string"==typeof e?e:i,o[1]=d;for(var l=2;l<a;l++)o[l]=r[l];return t.createElement.apply(null,o)}return t.createElement.apply(null,r)}u.displayName="MDXCreateElement"},6437:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>d,toc:()=>l});var t=r(7462),i=(r(7294),r(3905));const a={slug:"redis-ae-examples",title:"\u5982\u4f55\u4f7f\u7528 AE \u5b9e\u73b0\u7f51\u7edc\u7f16\u7a0b\u3001\u591a\u7ebf\u7a0b\u7f16\u7a0b\u548c\u5f02\u6b65\u7f16\u7a0b\u7b49\u65b9\u9762\u7684\u5e94\u7528",authors:{name:"Henry Tien",title:"SDE",url:"https://github.com/henrytien",image_url:"https://github.com/henrytien.png"},tags:["redis","ae","tcp"]},o=void 0,d={permalink:"/redis-reading/blog/redis-ae-examples",editUrl:"https://github.com/code-reading-lab/redis-reading/tree/docs/blog/2023-04-04-redis-ae-examples.md",source:"@site/blog/2023-04-04-redis-ae-examples.md",title:"\u5982\u4f55\u4f7f\u7528 AE \u5b9e\u73b0\u7f51\u7edc\u7f16\u7a0b\u3001\u591a\u7ebf\u7a0b\u7f16\u7a0b\u548c\u5f02\u6b65\u7f16\u7a0b\u7b49\u65b9\u9762\u7684\u5e94\u7528",description:"\u4ee5\u4e0b\u662f\u4e00\u4e9b\u4f7f\u7528 AE \u5b9e\u73b0\u7f51\u7edc\u7f16\u7a0b\u3001\u591a\u7ebf\u7a0b\u7f16\u7a0b\u548c\u5f02\u6b65\u7f16\u7a0b\u7b49\u65b9\u9762\u5e94\u7528\u7684\u793a\u4f8b\u3002",date:"2023-04-04T00:00:00.000Z",formattedDate:"April 4, 2023",tags:[{label:"redis",permalink:"/redis-reading/blog/tags/redis"},{label:"ae",permalink:"/redis-reading/blog/tags/ae"},{label:"tcp",permalink:"/redis-reading/blog/tags/tcp"}],readingTime:3.675,hasTruncateMarker:!1,authors:[{name:"Henry Tien",title:"SDE",url:"https://github.com/henrytien",image_url:"https://github.com/henrytien.png",imageURL:"https://github.com/henrytien.png"}],frontMatter:{slug:"redis-ae-examples",title:"\u5982\u4f55\u4f7f\u7528 AE \u5b9e\u73b0\u7f51\u7edc\u7f16\u7a0b\u3001\u591a\u7ebf\u7a0b\u7f16\u7a0b\u548c\u5f02\u6b65\u7f16\u7a0b\u7b49\u65b9\u9762\u7684\u5e94\u7528",authors:{name:"Henry Tien",title:"SDE",url:"https://github.com/henrytien",image_url:"https://github.com/henrytien.png",imageURL:"https://github.com/henrytien.png"},tags:["redis","ae","tcp"]},nextItem:{title:"Welcome",permalink:"/redis-reading/blog/welcome"}},s={authorsImageUrls:[void 0]},l=[{value:"\u7f51\u7edc\u7f16\u7a0b\uff1a",id:"\u7f51\u7edc\u7f16\u7a0b",level:2},{value:"\u670d\u52a1\u7aef\u4ee3\u7801",id:"\u670d\u52a1\u7aef\u4ee3\u7801",level:3},{value:"\u5ba2\u6237\u7aef\u4ee3\u7801",id:"\u5ba2\u6237\u7aef\u4ee3\u7801",level:3}],c={toc:l},f="wrapper";function p(e){let{components:n,...r}=e;return(0,i.kt)(f,(0,t.Z)({},c,r,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"\u4ee5\u4e0b\u662f\u4e00\u4e9b\u4f7f\u7528 AE \u5b9e\u73b0\u7f51\u7edc\u7f16\u7a0b\u3001\u591a\u7ebf\u7a0b\u7f16\u7a0b\u548c\u5f02\u6b65\u7f16\u7a0b\u7b49\u65b9\u9762\u5e94\u7528\u7684\u793a\u4f8b\u3002"),(0,i.kt)("h2",{id:"\u7f51\u7edc\u7f16\u7a0b"},"\u7f51\u7edc\u7f16\u7a0b\uff1a"),(0,i.kt)("p",null,"\u4f7f\u7528 AE \u53ef\u4ee5\u65b9\u4fbf\u5730\u5b9e\u73b0\u7f51\u7edc\u7f16\u7a0b\uff0c\u4f8b\u5982\uff0c\u53ef\u4ee5\u4f7f\u7528 AE \u5b9e\u73b0\u4e00\u4e2a\u7b80\u5355\u7684 TCP \u670d\u52a1\u5668\uff0c\u5982\u4e0b\u6240\u793a\uff1a"),(0,i.kt)("h3",{id:"\u670d\u52a1\u7aef\u4ee3\u7801"},"\u670d\u52a1\u7aef\u4ee3\u7801"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include "ae.h"\n\n#define PORT 5000\n\n// accept \u56de\u8c03\u51fd\u6570\uff0c\u7528\u4e8e\u63a5\u6536\u65b0\u8fde\u63a5\nvoid acceptTcpHandler(aeEventLoop *loop, int fd, void *clientdata, int mask) {\n    // \u63a5\u6536\u65b0\u8fde\u63a5\n    int clientfd = accept(fd, NULL, NULL);\n    if (clientfd == -1) {\n        fprintf(stderr, "accept failed, errno: %d\\n", errno);\n        return;\n    }\n    // \u4e3a\u65b0\u8fde\u63a5\u6dfb\u52a0\u8bfb\u4e8b\u4ef6\n    aeCreateFileEvent(loop, clientfd, AE_READABLE, readTcpHandler, NULL);\n}\n\n// \u8bfb\u4e8b\u4ef6\u56de\u8c03\u51fd\u6570\uff0c\u7528\u4e8e\u63a5\u6536\u5ba2\u6237\u7aef\u53d1\u9001\u7684\u6570\u636e\nvoid readTcpHandler(aeEventLoop *loop, int fd, void *clientdata, int mask) {\n    char buffer[1024];\n    // \u8bfb\u53d6\u5ba2\u6237\u7aef\u53d1\u9001\u7684\u6570\u636e\n    int nread = read(fd, buffer, sizeof(buffer));\n    if (nread == -1) {\n        fprintf(stderr, "read failed, errno: %d\\n", errno);\n        close(fd);\n        aeDeleteFileEvent(loop, fd, AE_READABLE);\n        return;\n    } else if (nread == 0) {\n        close(fd);\n        aeDeleteFileEvent(loop, fd, AE_READABLE);\n        return;\n    }\n    buffer[nread] = \'\\0\';\n    // \u6253\u5370\u63a5\u6536\u5230\u7684\u6570\u636e\n    printf("read data: %s\\n", buffer);\n}\n\nint main() {\n    // \u521b\u5efa AE \u5b9e\u4f8b\n    aeEventLoop *loop = aeCreateEventLoop(1024);\n    if (loop == NULL) {\n        fprintf(stderr, "create event loop failed\\n");\n        exit(EXIT_FAILURE);\n    }\n    // \u521b\u5efa\u76d1\u542c\u5957\u63a5\u5b57\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd == -1) {\n        fprintf(stderr, "create socket failed, errno: %d\\n", errno);\n        exit(EXIT_FAILURE);\n    }\n    // \u7ed1\u5b9a\u76d1\u542c\u5957\u63a5\u5b57\u5230\u6307\u5b9a\u7aef\u53e3\n    struct sockaddr_in addr;\n    memset(&addr, 0, sizeof(addr));\n    addr.sin_family = AF_INET;\n    addr.sin_addr.s_addr = htonl(INADDR_ANY);\n    addr.sin_port = htons(PORT);\n    if (bind(sockfd, (struct sockaddr*)&addr, sizeof(addr)) == -1) {\n        fprintf(stderr, "bind failed, errno: %d\\n", errno);\n        exit(EXIT_FAILURE);\n    }\n    // \u5f00\u59cb\u76d1\u542c\n    if (listen(sockfd, 1024) == -1) {\n        fprintf(stderr, "listen failed, errno: %d\\n", errno);\n        exit(EXIT_FAILURE);\n    }\n    // \u4e3a\u76d1\u542c\u5957\u63a5\u5b57\u6dfb\u52a0\u8bfb\u4e8b\u4ef6\n    if (aeCreateFileEvent(loop, sockfd, AE_READABLE, acceptTcpHandler, NULL) == -1) {\n        fprintf(stderr, "create file event failed, errno: %d\\n", errno);\n        exit(EXIT_FAILURE);\n    }\n    // \u8fdb\u5165\u4e8b\u4ef6\u5faa\u73af\n    aeMain(loop);\n    // \u9500\u6bc1 AE \u5b9e\u4f8b\n    aeDeleteEventLoop(loop);\n    return 0;\n}\n')),(0,i.kt)("h3",{id:"\u5ba2\u6237\u7aef\u4ee3\u7801"},"\u5ba2\u6237\u7aef\u4ee3\u7801"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\n#define SERVER_IP "127.0.0.1"\n#define SERVER_PORT 5000\n\nint main() {\n    // \u521b\u5efa\u5957\u63a5\u5b57\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd == -1) {\n        fprintf(stderr, "create socket failed, errno: %d\\n", errno);\n        exit(EXIT_FAILURE);\n    }\n    // \u8fde\u63a5\u670d\u52a1\u5668\n    struct sockaddr_in addr;\n    memset(&addr, 0, sizeof(addr));\n    addr.sin_family = AF_INET;\n    addr.sin_addr.s_addr = inet_addr(SERVER_IP);\n    addr.sin_port = htons(SERVER_PORT);\n    int ret = connect(sockfd, (struct sockaddr*)&addr, sizeof(addr));\n    if (ret == -1) {\n        if (errno == EINPROGRESS) {\n            // \u8fde\u63a5\u6b63\u5728\u8fdb\u884c\u4e2d\uff0c\u9700\u8981\u7b49\u5f85\u8fde\u63a5\u5b8c\u6210\u6216\u8005\u8d85\u65f6\n            fd_set rset, wset;\n            FD_ZERO(&rset);\n            FD_SET(sockfd, &rset);\n            wset = rset;\n            struct timeval tv;\n            tv.tv_sec = 5; // \u8d85\u65f6\u65f6\u95f4 5 \u79d2\n            tv.tv_usec = 0;\n            ret = select(sockfd + 1, &rset, &wset, NULL, &tv);\n            if (ret == -1) {\n                fprintf(stderr, "select failed, errno: %d\\n", errno);\n                close(sockfd);\n                exit(EXIT_FAILURE);\n            } else if (ret == 0) {\n                fprintf(stderr, "connect timeout\\n");\n                close(sockfd);\n                exit(EXIT_FAILURE);\n            } else {\n                int error = 0;\n                socklen_t len = sizeof(error);\n                getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &error, &len);\n                if (error != 0) {\n                    fprintf(stderr, "connect failed, errno: %d\\n", error);\n                    close(sockfd);\n                    exit(EXIT_FAILURE);\n                }\n            }\n        } else {\n            fprintf(stderr, "connect failed, errno: %d\\n", errno);\n            close(sockfd);\n            exit(EXIT_FAILURE);\n        }\n    }\n    // \u53d1\u9001\u6570\u636e\n    const char *data = "hello, world";\n    int nwrite = write(sockfd, data, strlen(data));\n    if (nwrite == -1) {\n        fprintf(stderr, "write failed, errno: %d\\n", errno);\n        close(sockfd);\n        exit(EXIT_FAILURE);\n    }\n    // \u63a5\u6536\u6570\u636e\n    char buffer[1024];\n    int nread = read(sockfd, buffer, sizeof(buffer));\n    if (nread == -1) {\n        fprintf(stderr, "read failed, errno: %d\\n", errno);\n        close(sockfd);\n        exit(EXIT_FAILURE);\n    } else if (nread == 0) {\n        fprintf(stderr, "server closed connection\\n");\n        close(sockfd);\n        exit(EXIT_FAILURE);\n    }\n    buffer[nread] = \'\\0\';\n    // \u6253\u5370\u63a5\u6536\u5230\u7684\u6570\u636e\n    printf("received data: %s\\n", buffer);\n    // \u5173\u95ed\u5957\u63a5\u5b57\n    close(sockfd);\n    return 0;\n}\n')))}p.isMDXComponent=!0}}]);